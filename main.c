#include <efi.h>
#include <efilib.h>
#include <libsmbios.h>
#include <stdbool.h>
#include <stdlib.h>
#include "INCLUDE/CryptoAndModuleSigEnforcement/crypto.c"

// For processes
#define MAX_PROCESSES 256

// For legacy console output
#define cls ST->ConOut->ClearScreen(ST->ConOut)
#define printosver Print(L"PINAUK UEFI KERNEL VERSION ALPHA")
#define bluescrcolor ST->ConOut->SetAttribute(ST->ConOut, EFI_WHITE | (EFI_BLUE << 4))

// For font rendering (couldn't find a less appropriate place for it)
#define GLYPH_WIDTH 8
#define GLYPH_HEIGHT 16
#define GLYPHS_PER_ROW 16
#define GLYPHS_PER_COL 16

// Some shit for architectures, no-one will ever compile this kernel for RISC-V 64-bit, heck not even for ARM
#if defined(_M_X64) || defined(__x86_64__)
static CHAR16* ArchName = L"x86 64-bit";
#elif defined(_M_IX86) || defined(__i386__)
static CHAR16* ArchName = L"x86 32-bit";
#elif defined (_M_ARM64) || defined(__aarch64__)
static CHAR16* ArchName = L"ARM 64-bit";
#elif defined (_M_ARM) || defined(__arm__)
static CHAR16* ArchName = L"ARM 32-bit";
#elif defined (_M_RISCV64) || (defined(__riscv) && (__riscv_xlen == 64))
static CHAR16* ArchName = L"RISC-V 64-bit";
// What on Earth is you fucking architecture?
#else
#  error Unsupported architecture
#endif
void printstr(UINT32* framebuffer_base, uint32_t pixels_per_scanline, uint32_t screen_height, char c[]);
uint32_t currtextx, currtexty = 0;
void test_sha256();
// Why the fuck is it here and not in a custom libc implementation?
char* strcpy(char* dest, const char* src) 
{
	char* orig = dest;
	while ((*dest++ = *src++));
	return orig;
}
char* strtok(char* str, char delim) 
{
	static char* next = NULL;

	if (str != NULL) 
	{
		next = str;
	}

	if (next == NULL || *next == '\0') 
	{
		return NULL;
	}

	char* token_start = next;

	// Skip over characters until we find the delimiter or end
	while (*next != '\0' && *next != delim) 
	{
		next++;
	}

	// If we stopped at a delimiter, replace it with '\0' and move past it
	if (*next == delim) 
	{
		*next = '\0';
		next++;
	}

	return token_start;
}

// WARNING: A VEEEERY GROSS HACK HACK HACK HACK HACK HACK HACK HACK AHEAD
int CharToGlyph(char c) 
{
	switch (c) 
	{
	case ' ': return 0x0;
	case 'A': return 0x1;
	case 'B': return 0x2;
	case 'C': return 0x3;
	case 'D': return 0x4;
	case 'E': return 0x5;
	case 'F': return 0x6;
	case 'G': return 0x7;
	case 'H': return 0x8;
	case 'I': return 0x9;
	case 'J': return 0xA;
	case 'K': return 0xB;
	case 'L': return 0xC;
	case 'M': return 0xD;
	case 'N': return 0xE;
	case 'O': return 0xF;
	case 'P': return 0x10;
	case 'Q': return 0x11;
	case 'R': return 0x12;
	case 'S': return 0x13;
	case 'T': return 0x14;
	case 'U': return 0x15;
	case 'V': return 0x16;
	case 'W': return 0x17;
	case 'X': return 0x18;
	case 'Y': return 0x19;
	case 'Z': return 0x1A;
	default: return -1;
	}
}

// Now, idk is it used or no neither I give it a shit

/// <summary>
/// Gets a string length
/// </summary>
/// <param name="str">ur string</param>
/// <returns>Length of string **MINUS 4**</returns> (I guess minus 4, didn't really test it)
UINTN strlen(const char* str) 
{
	UINTN len = 0;
	while (*str++) len++;
	return len;
}
// Basically a soup of everything that belongs here and what doesn't
UINT32 font_glyphs[256][GLYPH_HEIGHT][GLYPH_WIDTH];
void kernel_panic(UINT32* framebuffer_base, uint32_t pixels_per_scanline, uint32_t screen_height, const char* errorcode);
int isNeoTermOutCrash = 0;
void createProcess(const char* path);
//void draw_char(UINT32* framebuffer, UINT32 pitch, UINT32 x, UINT32 y, char c);
//void draw_string(UINT32* framebuffer, UINT32 pitch, UINT32 x, UINT32 y, char c[1024]);
void PutChar(UINT32* framebuffer_base, uint32_t pixels_per_scanline, uint32_t x, uint32_t y, char c, uint32_t fg, uint32_t bg);
char char_to_vga_index(char c);
void print(UINT32* framebuffer_base, uint32_t pixels_per_scanline, uint32_t x, uint32_t y, char c[], uint32_t fg, uint32_t bg);

void neotermout_cls(UINT32* framebuffer, uint32_t width, uint32_t height, uint32_t fg, uint32_t bg);	// Fuck it's mostly unused for anything real anyways
int find_free_slot();
// Tri-state status for Secure Boot: -1 = Setup, 0 = Disabled, 1 = Enabled
INTN SecureBootStatus = 0;

void Console();
void ExecCmd(CHAR16 inpbuf[128]);




/*void draw_pixel(UINT32* framebuffer, UINT32 width, UINT32 x, UINT32 y, UINT32 color)
{
	framebuffer[y * width + x] = color;
}*/
void KK() 
{
	EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL* InputEx;
	EFI_GUID SimpleTextInputExProtocolGuid = EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL_GUID;
	char
	Status = uefi_call_wrapper(BS->LocateProtocol, 3,
		&SimpleTextInputExProtocolGuid,
		NULL,
		(VOID**)&InputEx);
	if (EFI_ERROR(Status)) 
	{
		Print(L"Failed to locate SimpleTextInputEx protocol\n");	// Better to make it kernel_panic, but idrk
		return Status;
	}
}
void draw_pixel(UINT32* framebuffer, UINT32 pitch, UINT32 x, UINT32 y, UINT32 color) 
{
	framebuffer[y * pitch + x] = color;
}
EFI_FILE_PROTOCOL* load_file(
	EFI_HANDLE ImageHandle,
	EFI_SYSTEM_TABLE* SystemTable,
	CHAR16* path
) {
	EFI_LOADED_IMAGE_PROTOCOL* loaded_image = NULL;
	EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* fs = NULL;
	EFI_FILE_PROTOCOL* root = NULL;
	EFI_FILE_PROTOCOL* file = NULL;

	// Get Loaded Image Protocol
	SystemTable->BootServices->HandleProtocol(
		ImageHandle,
		&gEfiLoadedImageProtocolGuid,
		(void**)&loaded_image
	);

	// Get the file system
	SystemTable->BootServices->HandleProtocol(
		loaded_image->DeviceHandle,
		&gEfiSimpleFileSystemProtocolGuid,
		(void**)&fs
	);

	// Open volume (root dir)
	fs->OpenVolume(fs, &root);

	// Actually open the file
	EFI_STATUS status = root->Open(
		root,
		&file,
		path,
		EFI_FILE_MODE_READ,
		0
	);

	if (EFI_ERROR(status)) {
		Print(L"Open file failed: %r\n", status);
		for (;;);
		//kernel_panic("CRITICAL_FILE_NOT_FOUND");
		return NULL;
	}

	return file;
}

static EFI_STATUS PrintSystemInfo(VOID)
{
	EFI_STATUS Status;
	SMBIOS_STRUCTURE_POINTER Smbios;
	SMBIOS_STRUCTURE_TABLE* SmbiosTable;
	SMBIOS3_STRUCTURE_TABLE* Smbios3Table;
	UINT8 Found = 0, * Raw, * SecureBoot, * SetupMode;
	UINTN MaximumSize, ProcessedSize = 0;

	Print(L"UEFI v%d.%d (%s, 0x%08X)\n", gST->Hdr.Revision >> 16, gST->Hdr.Revision & 0xFFFF,
		gST->FirmwareVendor, gST->FirmwareRevision);

	Status = LibGetSystemConfigurationTable(&SMBIOS3TableGuid, (VOID**)&Smbios3Table);
	if (Status == EFI_SUCCESS) 
	{
		Smbios.Hdr = (SMBIOS_HEADER*)Smbios3Table->TableAddress;
		MaximumSize = (UINTN)Smbios3Table->TableMaximumSize;
	}
	else 
	{
		Status = LibGetSystemConfigurationTable(&SMBIOSTableGuid, (VOID**)&SmbiosTable);
		if (EFI_ERROR(Status))
			return EFI_NOT_FOUND;
		Smbios.Hdr = (SMBIOS_HEADER*)(UINTN)SmbiosTable->TableAddress;
		MaximumSize = (UINTN)SmbiosTable->TableLength;
	}

	while ((Smbios.Hdr->Type != 0x7F) && (Found < 2)) 
	{
		Raw = Smbios.Raw;
		if (Smbios.Hdr->Type == 0) 
		{
			Print(L"%a %a\n", LibGetSmbiosString(&Smbios, Smbios.Type0->Vendor),
				LibGetSmbiosString(&Smbios, Smbios.Type0->BiosVersion));
			Found++;
		}
		if (Smbios.Hdr->Type == 1) 
		{
			Print(L"%a %a\n", LibGetSmbiosString(&Smbios, Smbios.Type1->Manufacturer),
				LibGetSmbiosString(&Smbios, Smbios.Type1->ProductName));
			Found++;
		}
		LibGetSmbiosString(&Smbios, -1);
		ProcessedSize += (UINTN)Smbios.Raw - (UINTN)Raw;
		if (ProcessedSize > MaximumSize) 
		{
			Print(L"%EAborting system report due to noncompliant SMBIOS%N\n");
			return EFI_ABORTED;
		}
	}

	SecureBoot = LibGetVariable(L"SecureBoot", &EfiGlobalVariable);
	SetupMode = LibGetVariable(L"SetupMode", &EfiGlobalVariable);
	SecureBootStatus = ((SecureBoot != NULL) && (*SecureBoot != 0)) ? 1 : 0;
	// You'd expect UEFI platforms to properly clear SetupMode after they
	// installed all the certs... but most of them don't. Hence Secure Boot
	// disabled having precedence over SetupMode. Looking at you OVMF!
	if ((SetupMode != NULL) && (*SetupMode != 0))
		SecureBootStatus *= -1;
	// Wasteful, but we can't highlight "Enabled"/"Setup" from a %s argument...
	if (SecureBootStatus > 0)
		Print(L"Secure Boot status: %HEnabled%N\n");
	else if (SecureBootStatus < 0)
		Print(L"Secure Boot status: %ESetup%N\n");
	else
		Print(L"Secure Boot status: Disabled\n");

	return EFI_SUCCESS;
}
#pragma pack(push, 1)
typedef struct 
{
	UINT8  signature[2];   // 'B' 'M'
	UINT32 fileSize;
	UINT32 reserved;
	UINT32 dataOffset;

	UINT32 headerSize;
	INT32  width;
	INT32  height;
	UINT16 planes;
	UINT16 bpp;
	UINT32 compression;
	UINT32 imageSize;
	INT32  xPelsPerMeter;
	INT32  yPelsPerMeter;
	UINT32 colorsUsed;
	UINT32 importantColors;
} BMPHeader;
#pragma pack(pop)
EFI_SIMPLE_POINTER_PROTOCOL* mouse;	// Fuck it's unused as of 15.05.2025 anyways

// Application entrypoint (must be set to 'efi_main' for gnu-efi crt0 compatibility)
EFI_STATUS efi_main(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable)
{
	UINTN Event;

#if defined(_GNU_EFI)
	InitializeLib(ImageHandle, SystemTable);
#endif
	cls;
	PrintSystemInfo();
	bluescrcolor;
	ST->ConOut->OutputString(ST->ConOut, L"Hello with new text color!\r\n");
	cls;
	printosver;
	Print(L"\nRunning on a CPU architecture: %s", ArchName);
	Print(L"\n");
	// Disable the watchdog timer so that the PC doesn't reboot in 5 minutes
	gBS->SetWatchdogTimer(0, 0, 0, NULL);
	Print(L"Disabled the watchdog timer\n");

	// Time to init gfx!
	EFI_GRAPHICS_OUTPUT_PROTOCOL *gop;
	


	EFI_GUID gopGuid = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;
	EFI_STATUS status = uefi_call_wrapper(BS->LocateProtocol, 3, &gopGuid, NULL, (void**)&gop);
	if (status == EFI_SUCCESS) 
	{
		Print(L"GOP initialization succeeded!\n");
	}
	else if (status != EFI_SUCCESS) 
	{
		Print(L"\nGOP initialization failed!\n");
		//kernel_panic("GOP_INIT_FAILED");
		while (1 == 1)	// Why is it here? kernel_panic already loops infinitely
		{

		}
	}

	//UINT32* framebuffer = (UINT32*)gop->Mode->FrameBufferBase;	// Fucking why commenting it out
	UINT32* framebuffer = (UINT32*)gop->Mode->FrameBufferBase;	// and writing it on the next line?
	Print(L"Set the GOP framebuffer\n");
	//UINT32 width = gop->Mode->Info->HorizontalResolution;	// ???
	UINT32 pitch = gop->Mode->Info->PixelsPerScanLine;
	Print(L"Set the GOP width\n");	// ik it's pitch, but i don't really give it a fuck
	UINT32 height = gop->Mode->Info->VerticalResolution;
	Print(L"Set the GOP height\n");
	Print(L"Screen resolution is: %d x %d", pitch, height);
	Print(L"\n");
	EFI_FILE_PROTOCOL* file = load_file(ImageHandle, SystemTable, L"\\syslogo.bmp");
	if (file == NULL) 
	{
		Print(L"Failed to open syslogo.bmp\n");
		while (1 == 1)	// Why not kernel_panic?
		{

		}
		//return EFI_NOT_FOUND;
	}

#pragma pack(push, 1)
	typedef struct 
	{
		UINT16 signature;        // Should be 'BM'
		UINT32 file_size;
		UINT32 reserved;
		UINT32 pixel_array_offset;
	} BMPHeader;

	typedef struct 
	{
		UINT32 header_size;
		INT32 width;
		INT32 height;
		UINT16 planes;
		UINT16 bits_per_pixel;
		UINT32 compression;
		UINT32 image_size;
		// ... we can add more later if we ever need to, but why??????
	} DIBHeader;
#pragma pack(pop)

	BMPHeader bmp_header;
	DIBHeader dib_header;
	UINTN size = sizeof(BMPHeader);
	file->SetPosition(file, 0);
	file->Read(file, &size, &bmp_header);

	if (bmp_header.signature != 0x4D42) 
	{
		Print(L"Not a BMP file\n");
		return EFI_ABORTED;
	}

	size = sizeof(DIBHeader);
	file->Read(file, &size, &dib_header);

	Print(L"BMP Size: %dx%d, %d bpp\n", dib_header.width, dib_header.height, dib_header.bits_per_pixel);
	UINT32 pixel_data_offset = bmp_header.pixel_array_offset;
	UINT32 image_width = dib_header.width;
	UINT32 image_height = dib_header.height;
	UINT16 bpp = dib_header.bits_per_pixel;

	if (bpp != 24) 
	{
		Print(L"Only 24bpp BMPs are supported.\n");
		kernel_panic(framebuffer, pitch, height, "BMP_NOT_24BIT");
		return EFI_ABORTED;	// Again, why not kernel_panic?
	}

	// Each row is padded to 4-byte boundary
	UINT32 row_size = (image_width * 3 + 3) & ~3;
	UINT32 image_data_size = row_size * image_height;

	UINT8* pixel_data = AllocatePool(image_data_size);
	if (!pixel_data) 
	{
		Print(L"Out of memory\n");
		kernel_panic(framebuffer, pitch, height, "BMP_LOAD_OUT_OF_MEMORY");
		return EFI_ABORTED;	// Why not fucking kernel panic???
	}

	// Read pixel data
	file->SetPosition(file, pixel_data_offset);
	UINTN read_size = image_data_size;
	file->Read(file, &read_size, pixel_data);
	UINT32 scale = 8;

	scale = pitch / image_width;

	UINT32 scaled_width = image_width * scale;
	UINT32 scaled_height = image_height * scale;

	UINT32 offset_x = (pitch - scaled_width) / 2;
	UINT32 offset_y = (height - scaled_height) / 2;

	for (UINT32 y = 0; y < image_height; y++) 
	{
		for (UINT32 x = 0; x < image_width; x++) 
		{
			UINT32 row = image_height - 1 - y; // Turn it upside-down (BMPs are upside-down)
			UINT8* pixel = pixel_data + row * row_size + x * 3;
			UINT8 blue = pixel[0];
			UINT8 green = pixel[1];
			UINT8 red = pixel[2];
			UINT32 color = (red << 16) | (green << 8) | blue;

			// Draw a scale×scale block per source pixel (for integer scaling)
			for (UINT32 dy = 0; dy < scale; dy++) 
			{
				for (UINT32 dx = 0; dx < scale; dx++) 
				{
					draw_pixel(framebuffer, pitch, offset_x + x * scale + dx,
						offset_y + y * scale + dy,
						color);
				}
			}
		}
	}
	KK();
	EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL* InputEx;
	EFI_GUID SimpleTextInputExProtocolGuid = EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL_GUID;
	char
		Status = uefi_call_wrapper(BS->LocateProtocol, 3,
			&SimpleTextInputExProtocolGuid,
			NULL,
			(VOID**)&InputEx);
	if (EFI_ERROR(Status)) 
	{
		Print(L"Failed to locate SimpleTextInputEx protocol\n");
		kernel_panic(framebuffer, pitch, height, "SIMPLE_TEXT_INPUT_EX_LOCATION_FAILED");
		return Status;
	}
	gBS->Stall(10);

	UINTN memoryMapSize = 0;
	UINTN extraPadding = 8192;
	EFI_MEMORY_DESCRIPTOR* memoryMap = NULL;
	UINTN mapKey;
	UINTN descriptorSize;
	UINT32 descriptorVersion;

	// First call to get the required buffer size
	gBS->GetMemoryMap(&memoryMapSize, memoryMap, &mapKey, &descriptorSize, &descriptorVersion);

	// Allocate the memory map buffer (add extra room just in case)
	memoryMap = AllocatePool(memoryMapSize + extraPadding);

	// Call again to actually get the memory map
	//gBS->GetMemoryMap(&memoryMapSize, memoryMap, &mapKey, &descriptorSize, &descriptorVersion);

	// Finally, exit boot services
	//status = gBS->ExitBootServices(ImageHandle, mapKey);
	if (EFI_ERROR(status)) {
		// Memory map likely changed
	//	kernel_panic("EXITBOOTSERVICES_MEMORYMAP_LIKELY_CHANGED");
	}
	// No more boot services, yahoo!
	//isNeoTermOutCrash = 1;
	neotermout_cls(framebuffer, pitch, height, 0xFFFFFFFF, 0x00000098);
	print(framebuffer, pitch, 0, 0, "NEOTERMOUT(TM)", 0xFFFFFFFF, 0x00000098);
	print(framebuffer, pitch, 0, 16, "THIS MESSAGE CONFIRMS THAT THE NEW TERMINAL OUTPUT", 0xFFFFFFFF, 0x00000098);
	print(framebuffer, pitch, 0, 32, "IS INDEED WORKING CORRECTLY", 0xFFFFFFFF, 0x00000098);
	// The only usages of the "trademarked" NeoTermOut (as of 15.05.2025)

	// ???????????
	//while (1) 
	//{
	//
	//}

	test_sha256();
	kernel_panic(framebuffer, pitch, height, "TEST_KERNEL_PANIC"); // For testing the new kernel panic function
	Console();
}
static void print_hash_utf16(const uint8_t* hash) 
{
	const CHAR16 hex[] = u"0123456789abcdef";
	CHAR16 buf[65]; // 64 hex chars + null terminator
	for (int i = 0; i < 32; ++i) {
		buf[i * 2] = hex[hash[i] >> 4];
		buf[i * 2 + 1] = hex[hash[i] & 0xF];
	}
	buf[64] = 0; // null terminator
	Print("\n");
	Print(buf); // Or whatever outputs CHAR16*
}


void test_sha256() 
{
	const char* msg = "abc"; // still ASCII here
	uint8_t hash[32];
	sha256_compute((const uint8_t*)msg, strlen(msg), hash);
	print_hash_utf16(hash); // now prints it as CHAR16 string
}

void Console() 
{
	Print("\n");
	Print(">");
	CHAR16 inpbuffer[128];  // Buffer to store input
	UINTN index = 0;
	while (index < sizeof(inpbuffer) / sizeof(CHAR16) - 1) 
	{
		EFI_INPUT_KEY Key;
		EFI_STATUS Status;

		// Wait for key event
		UINTN EventIndex;
		ST->BootServices->WaitForEvent(1, &ST->ConIn->WaitForKey, &EventIndex);

		// Read the key
		Status = ST->ConIn->ReadKeyStroke(ST->ConIn, &Key);
		if (EFI_ERROR(Status)) 
		{
			continue;
		}

		// Handle special keys
		if (Key.UnicodeChar == CHAR_CARRIAGE_RETURN) 
		{
			inpbuffer[index] = L'\0';  // Null-terminate input
			// Try to execute the command
			ExecCmd(inpbuffer);
			index = 0;
			Print(L"\n>");  // Optional: prompt again
		}

		if (Key.UnicodeChar == CHAR_BACKSPACE && index > 0) 
		{
			index--;
			Print(L"\b \b");  // Erase the last character
			continue;
		}

		if (Key.UnicodeChar >= 32 && Key.UnicodeChar <= 126) 
		{
			inpbuffer[index++] = Key.UnicodeChar;
			Print(L"%c", Key.UnicodeChar);  // Echo back
		}
	}
	return;
}

//void shell_echo(char* argv[]) {
//	int start = 1;
//	int newline = 1;
//
//	// Print the arguments
//	for (int i = start; i < argv; ++i) {
//		Print(L"%s", argv[i]);
//		if (i < argv - 1)
//			Print(" ");
//	}
//
//	if (newline) 
//	{
//		Print("\n");
//	}
//}
void shell_echo(char* argv[]) 
{
	int i = 0;
	while (argv[i] != NULL) {
		Print(L"%c ", argv[i]);
		++i;
	}
	Print(L"\n");
}


//void ExecEcho(CHAR16 wholeCommand[])
//{
//	char out[128];
//	for (int i = 0; i < 127 && wholeCommand[i] != 0; i++) {
//		out[i] = (char)wholeCommand[i];
//		out[i + 1] = '\0';
//	}
//
//	char original[128];
//	strcpy(original, out);
//
//	char* trimmed = original + 5;
//
//	shell_echo(trimmed);
//}
 
 
 
void ExecEcho(CHAR16 wholeCommand[]) 
{
	char out[128];
	for (int i = 0; i < 127 && wholeCommand[i] != 0; i++) {
		out[i] = (char)wholeCommand[i];
		out[i + 1] = '\0';
	}

	// Tokenize out into argv[]
	char* argv[10];
	int argc = 0;
	char* token = strtok(out, " ");
	while (token && argc < 10) {
		argv[argc++] = token;
		token = strtok(NULL, " ");
	}
	argv[argc] = NULL;  // Null-terminate

	if (argc > 1) {
		shell_echo(&argv[1]);  // Skip "echo"
	}
}

 
 
 
 

//void ExecCmd(CHAR16 inpbuf[]) 
//{
//	Print(L"\n%s", inpbuf[1]);
//	Print(L"\n%s", inpbuf[2]);
//	Print(L"\n%s", inpbuf[3]);
//	Print(L"\n%s", inpbuf[4]);
//	if (inpbuf[1] == "e" && inpbuf[2] == "c" && inpbuf[3] == "h" && inpbuf[4] == "o")
//	{
//		ExecEcho(inpbuf);
//	}
//	else 
//	{
//		Print(L"\nCommand not found!\n");
//	}
//}
void ExecCmd(CHAR16* input) 
{
	CHAR16* command = StrDuplicate(input);  // Make a mutable copy
	CHAR16* token;
	CHAR16* next_token;
	CHAR16* args[10];
	int arg_count = 0;

	for (token = strtok(/*command,*/ L" ", &next_token);
		token != NULL && arg_count < 10;
		token = strtok(/*NULL,*/ L" ", &next_token)) 
	{
		args[arg_count++] = token;
	}

	if (/*arg_count >= 1 && StrCmp(args[0], "ECHO"*/
		args[0] == (short)"echo") 
	{
		ExecEcho(input);  // Or pass args
	}
	else 
	{
		Print(L"\nCommand not found: ", args[0]);
	}

	FreePool(command);  // if StrDuplicate used AllocatePool
			// Wait, I may've found the issue now
}


// The most important function
/*void kernel_panic(const char* errorcode)
{
	CHAR16 buffer[256];
	UINTN i;

	// Convert to CHAR16
	for (i = 0; errorcode[i] != '\0' && i < 255; i++) 
	{
		buffer[i] = (CHAR16)errorcode[i];
	}
	buffer[i] = 0; // NULL-terminate the string
	
		ST->ConOut->OutputString(ST->ConOut, L"\r\n*** KERNEL PANIC ***\r\n");
		ST->ConOut->OutputString(ST->ConOut, L"Error: ");
		ST->ConOut->OutputString(ST->ConOut, buffer);
		ST->ConOut->OutputString(ST->ConOut, L"\r\nSystem halted.\r\n");
	
	// Halt
	while (1) 
	{ 
		volatile int halt = 1;
		(void)halt;
	}
}*/
#include <intrin.h>
void ClearScreen(UINT32* framebuffer_base, uint32_t pixels_per_scanline, uint32_t screen_height, uint32_t clear_color)
{
	for (uint32_t y = 0; y < screen_height; ++y)
	{
		for (uint32_t x = 0; x < pixels_per_scanline; ++x)
		{
			framebuffer_base[y * pixels_per_scanline + x] = clear_color;
		}
	}
}

void kernel_panic(UINT32* framebuffer_base, uint32_t pixels_per_scanline, uint32_t screen_height, const char* errorcode)
{
	// Clear screen (optional)
	//for (uint32_t y = 0; y < screen_height; ++y)
	//{
	//	for (uint32_t x = 0; x < pixels_per_scanline; ++x)
	//	{
	//		framebuffer_base[y * pixels_per_scanline + x] = 0xFF0000; // Bright red background
	//	}
	//}
	ClearScreen(framebuffer_base, pixels_per_scanline, screen_height, 0x00000098);

	currtextx = 0;
	currtexty = 0;

	// All caps because I think I commented out the small letters glyphs
	printstr(framebuffer_base, pixels_per_scanline, screen_height, "*** KERNEL PANIC ***");
	currtextx = 0;	// Nasty hack to reset the text cursor position
	printstr(framebuffer_base, pixels_per_scanline, screen_height, "ERROR: ");
	currtextx = 0;	// Nasty hack to reset the text cursor position
	printstr(framebuffer_base, pixels_per_scanline, screen_height, errorcode);
	currtextx = 0;	// Nasty hack to reset the text cursor position
	printstr(framebuffer_base, pixels_per_scanline, screen_height, "SYSTEM HALTED.");
	currtextx = 0;	// Nasty hack to reset the text cursor position
	printstr(framebuffer_base, pixels_per_scanline, screen_height, "DO NOT TRY TO REPORT THIS TO THE DEV, THEY WON'T FIX IT ANYWAYS");
	currtextx = 0;	// Nasty hack to reset the text cursor position
	printstr(framebuffer_base, pixels_per_scanline, screen_height, "PLUS IT WORKED FINE ON MY MACHINE LMAO");
	currtextx = 0;	// Nasty hack to reset the text cursor position (if you still didn't get it from the prevoius six comments)
	printstr(framebuffer_base, pixels_per_scanline, screen_height, "seriously what'd u do");	// No-one will see it since I commented out the small letters glyphs, but whatever
	// Ehh whatever, it works now, and it is not corrupted YAHOOOOOOOOOOOOOOOOO!
	// Lol the code is more comments than actual code

	// Halt the CPU
	while (1)
	{
		__halt();

		//printstr(framebuffer_base, pixels_per_scanline, screen_height, "If you see me then the CPU isn't halted");
		// OK, it's not halted, and the output is also corrupted. Ehh, whatever, the OS is still for stooooooopid users who can't read error codes,
		// they will just scream and blame me for "NoT mAkInG mY oS wOrK pRoPeRlY", 
	}
}

// Font for the "trademarked" NeoTermOut
// Some are commented-out due to...
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
// umm...
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
// idk why, can't explain
//
//
//
//
// Well, I guess I can: otherwise I couldn't get it to work
// properly, so I just commented out the unused glyphs, and it worked!
// I guess it was a bug in the font loader, but I don't really care about it now, so I just left it like that
// That shit wasn't used anyways




uint8_t vgafont16[256 * 16] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x7e, 0x81, 0xa5, 0x81, 0x81, 0xbd, 0x99, 0x81, 0x81, 0x7e, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x7e, 0xff, 0xdb, 0xff, 0xff, 0xc3, 0xe7, 0xff, 0xff, 0x7e, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x6c, 0xfe, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x18, 0x3c, 0x3c, 0xe7, 0xe7, 0xe7, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x7e, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff,
// 	0x00, 0x00, 0x1e, 0x0e, 0x1a, 0x32, 0x78, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x3f, 0x33, 0x3f, 0x30, 0x30, 0x30, 0x30, 0x70, 0xf0, 0xe0, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x7f, 0x63, 0x7f, 0x63, 0x63, 0x63, 0x63, 0x67, 0xe7, 0xe6, 0xc0, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x18, 0x18, 0xdb, 0x3c, 0xe7, 0x3c, 0xdb, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfe, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x02, 0x06, 0x0e, 0x1e, 0x3e, 0xfe, 0x3e, 0x1e, 0x0e, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x7f, 0xdb, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x7c, 0xc6, 0x60, 0x38, 0x6c, 0xc6, 0xc6, 0x6c, 0x38, 0x0c, 0xc6, 0x7c, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x7e, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x7c, 0x7c, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0x7c, 0x7c, 0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x18, 0x3c, 0x3c, 0x3c, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00,
// 	0x18, 0x18, 0x7c, 0xc6, 0xc2, 0xc0, 0x7c, 0x06, 0x06, 0x86, 0xc6, 0x7c, 0x18, 0x18, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0xc2, 0xc6, 0x0c, 0x18, 0x30, 0x60, 0xc6, 0x86, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x38, 0x6c, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x3c, 0x66, 0xc3, 0xc3, 0xdb, 0xdb, 0xc3, 0xc3, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x7c, 0xc6, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0xc6, 0xfe, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x7c, 0xc6, 0x06, 0x06, 0x3c, 0x06, 0x06, 0x06, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x0c, 0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x0c, 0x0c, 0x1e, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0xfe, 0xc0, 0xc0, 0xc0, 0xfc, 0x06, 0x06, 0x06, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x38, 0x60, 0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0xfe, 0xc6, 0x06, 0x06, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x06, 0x06, 0x0c, 0x78, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x7c, 0xc6, 0xc6, 0x0c, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
// 	0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xde, 0xde, 0xde, 0xdc, 0xc0, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x66, 0x66, 0xfc, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xc0, 0xc0, 0xc2, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xf8, 0x6c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x62, 0x66, 0xfe, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0x60, 0xf0, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xde, 0xc6, 0xc6, 0x66, 0x3a, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x1e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0xcc, 0x78, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xe6, 0x66, 0x66, 0x6c, 0x78, 0x78, 0x6c, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xf0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xc6, 0xe6, 0xf6, 0xfe, 0xde, 0xce, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x60, 0x60, 0xf0, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xd6, 0xde, 0x7c, 0x0c, 0x0e, 0x00, 0x00,
 	0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x7c, 0xc6, 0xc6, 0x60, 0x38, 0x0c, 0x06, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xff, 0xdb, 0x99, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xdb, 0xff, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xc3, 0xc3, 0x66, 0x3c, 0x18, 0x18, 0x3c, 0x66, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xff, 0xc3, 0x86, 0x0c, 0x18, 0x30, 0x60, 0xc1, 0xc3, 0xff, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0x70, 0x38, 0x1c, 0x0e, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00, 0x00, 0x00, 0x00,
 	0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
 	0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xe0, 0x60, 0x60, 0x78, 0x6c, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x1c, 0x0c, 0x0c, 0x3c, 0x6c, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x38, 0x6c, 0x64, 0x60, 0xf0, 0x60, 0x60, 0x60, 0x60, 0xf0, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xcc, 0x78, 0x00,
 	0x00, 0x00, 0xe0, 0x60, 0x60, 0x6c, 0x76, 0x66, 0x66, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x06, 0x06, 0x00, 0x0e, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3c, 0x00,
 	0x00, 0x00, 0xe0, 0x60, 0x60, 0x66, 0x6c, 0x78, 0x78, 0x6c, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0xff, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0x0c, 0x1e, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0x60, 0x60, 0xf0, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0x60, 0x38, 0x0c, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x10, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xdb, 0xdb, 0xff, 0x66, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x0c, 0xf8, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xcc, 0x18, 0x30, 0x60, 0xc6, 0xfe, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x0e, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0e, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xc0, 0xc2, 0x66, 0x3c, 0x0c, 0x06, 0x7c, 0x00, 0x00,
 	0x00, 0x00, 0xcc, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x0c, 0x18, 0x30, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x10, 0x38, 0x6c, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xcc, 0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x60, 0x30, 0x18, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x38, 0x6c, 0x38, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x60, 0x60, 0x66, 0x3c, 0x0c, 0x06, 0x3c, 0x00, 0x00, 0x00,
 	0x00, 0x10, 0x38, 0x6c, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xc6, 0x00, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x60, 0x30, 0x18, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x66, 0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x18, 0x3c, 0x66, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x60, 0x30, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0xc6, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00,
 	0x38, 0x6c, 0x38, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00,
 	0x18, 0x30, 0x60, 0x00, 0xfe, 0x66, 0x60, 0x7c, 0x60, 0x60, 0x66, 0xfe, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x3b, 0x1b, 0x7e, 0xd8, 0xdc, 0x77, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x3e, 0x6c, 0xcc, 0xcc, 0xfe, 0xcc, 0xcc, 0xcc, 0xcc, 0xce, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x10, 0x38, 0x6c, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xc6, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x60, 0x30, 0x18, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x30, 0x78, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x60, 0x30, 0x18, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xc6, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x0c, 0x78, 0x00,
 	0x00, 0xc6, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0xc6, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x18, 0x18, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0, 0xc3, 0x7e, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x38, 0x6c, 0x64, 0x60, 0xf0, 0x60, 0x60, 0x60, 0x60, 0xe6, 0xfc, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0xff, 0x18, 0xff, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0xfc, 0x66, 0x66, 0x7c, 0x62, 0x66, 0x6f, 0x66, 0x66, 0x66, 0xf3, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x0e, 0x1b, 0x18, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0xd8, 0x70, 0x00, 0x00,
 	0x00, 0x18, 0x30, 0x60, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x0c, 0x18, 0x30, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x18, 0x30, 0x60, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x18, 0x30, 0x60, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x76, 0xdc, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
 	0x76, 0xdc, 0x00, 0xc6, 0xe6, 0xf6, 0xfe, 0xde, 0xce, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x3c, 0x6c, 0x6c, 0x3e, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x38, 0x6c, 0x6c, 0x38, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60, 0xc0, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x06, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0xc0, 0xc0, 0xc2, 0xc6, 0xcc, 0x18, 0x30, 0x60, 0xce, 0x9b, 0x06, 0x0c, 0x1f, 0x00, 0x00,
 	0x00, 0xc0, 0xc0, 0xc2, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xce, 0x96, 0x3e, 0x06, 0x06, 0x00, 0x00,
 	0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x6c, 0xd8, 0x6c, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0xd8, 0x6c, 0x36, 0x6c, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44,
 	0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa,
 	0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77,
 	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
 	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
 	0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
 	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xf6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
 	0x36, 0x36, 0x36, 0x36, 0x36, 0xf6, 0x06, 0xf6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
 	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x06, 0xf6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
 	0x36, 0x36, 0x36, 0x36, 0x36, 0xf6, 0x06, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
 	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
 	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
 	0x18, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
 	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
 	0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x30, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
 	0x36, 0x36, 0x36, 0x36, 0x36, 0xf7, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xf7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
 	0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x36, 0x36, 0x36, 0x36, 0x36, 0xf7, 0x00, 0xf7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
 	0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
 	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x18, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
 	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xff, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
 	0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
 	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
 	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
 	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
 	0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
 	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 0xd8, 0xd8, 0xd8, 0xdc, 0x76, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0xd8, 0xcc, 0xc6, 0xc6, 0xc6, 0xcc, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0xfe, 0xc6, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0xfe, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0xfe, 0xc6, 0x60, 0x30, 0x18, 0x30, 0x60, 0xc6, 0xfe, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0xd8, 0xd8, 0xd8, 0xd8, 0xd8, 0x70, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xc0, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x7e, 0x18, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0x6c, 0x38, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x6c, 0x6c, 0x6c, 0xee, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x1e, 0x30, 0x18, 0x0c, 0x3e, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0xdb, 0xdb, 0xdb, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x03, 0x06, 0x7e, 0xdb, 0xdb, 0xf3, 0x7e, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x1c, 0x30, 0x60, 0x60, 0x7c, 0x60, 0x60, 0x60, 0x30, 0x1c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x30, 0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x0c, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0c, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x0e, 0x1b, 0x1b, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
 	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xd8, 0xd8, 0xd8, 0x70, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x7e, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 0x00, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x38, 0x6c, 0x6c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x0f, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xec, 0x6c, 0x6c, 0x3c, 0x1c, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0xd8, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x70, 0xd8, 0x30, 0x60, 0xc8, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
void scroll(UINT32* framebuffer_base, uint32_t pixels_per_scanline, uint32_t screen_height, uint32_t bg_color)
{
	// Calculate how many pixel rows we scroll (one text line)
	uint32_t scroll_lines = GLYPH_HEIGHT;

	// For each row except the last scroll_lines
	for (uint32_t y = 0; y < screen_height - scroll_lines; ++y)
	{
		for (uint32_t x = 0; x < pixels_per_scanline; ++x)
		{
			framebuffer_base[y * pixels_per_scanline + x] = framebuffer_base[(y + scroll_lines) * pixels_per_scanline + x];
		}
	}

	// Clear the last GLYPH_HEIGHT lines
	for (uint32_t y = screen_height - scroll_lines; y < screen_height; ++y)
	{
		for (uint32_t x = 0; x < pixels_per_scanline; ++x)
		{
			framebuffer_base[y * pixels_per_scanline + x] = bg_color;
		}
	}
}

void printstr(UINT32* framebuffer_base, uint32_t pixels_per_scanline, uint32_t screen_height, char c[])
{
	Print(L"StrLen of c: %d", strlen(c));
	print(framebuffer_base, pixels_per_scanline, currtextx, currtexty, c, 0xFFFFFFFF, 0x00000098);
	currtextx += strlen(c) * GLYPH_WIDTH;

	// Scroll if we reached bottom
	if (currtexty + GLYPH_HEIGHT >= screen_height)
	{
		scroll(framebuffer_base, pixels_per_scanline, screen_height, 0x00000098); // dark blue
		currtexty -= GLYPH_HEIGHT; // Stay at last line
	}
	else
	{
		currtexty += GLYPH_HEIGHT;
	}

	if (currtextx > pixels_per_scanline)
	{
		currtextx = 0;
		currtexty += GLYPH_HEIGHT;
	}
}


void PutChar(UINT32* framebuffer_base, uint32_t pixels_per_scanline, uint32_t x, uint32_t y, char c, uint32_t fg, uint32_t bg) 
{
	uint8_t* glyph = &vgafont16[(uint8_t)c * 16];

	for (int row = 0; row < 16; ++row) 
	{
		uint8_t row_bits = glyph[row];
		for (int col = 0; col < 8; ++col) 
		{
			bool pixel_on = row_bits & (0x80 >> col);
			uint32_t* pixel_ptr = framebuffer_base +
				(y + row) * pixels_per_scanline +
				(x + col);
			*pixel_ptr = pixel_on ? fg : bg;
		}
	}
}
void print(UINT32* framebuffer_base, uint32_t pixels_per_scanline, uint32_t x, uint32_t y, char c[], uint32_t fg, uint32_t bg)
{
	//Print(L"StrLen of c: %d", strlen(c));	// Are you what's breaking  the output? :)
	for (int i = 0; i < strlen(c); i++)
	{
		PutChar(framebuffer_base, pixels_per_scanline, x + i * GLYPH_WIDTH, y, CharToGlyph(c[i]), fg, bg);
	}
}
void neotermout_cls(UINT32* framebuffer, uint32_t width, uint32_t height, uint32_t fg, uint32_t bg) 
{
	UINT32 currentX = 0;
	UINT32 currentY = 0;
	for (currentY; currentY <= height; currentY++) 
	{
		for (currentX; currentX <= width; currentX++) 
		{
			draw_pixel(framebuffer, width, currentX, currentY, bg);
		}
	}
}
struct CPUContext;
struct Process
{
	uint32_t process_id;
	struct CPUContext* context;
	// No memory mappings since no mem. paging currently, soon there will be one
	uint64_t sp; // Stack pointer
	enum ProcState processstate;
	struct Process* next;
};
struct Process* process_list_head = NULL;

struct CPUContext
{
	uint64_t rax;
	uint64_t rbx;
	uint64_t rcx;
	uint64_t rdx;
	uint64_t rsi;
	uint64_t rdi;
	uint64_t rbp;
	uint64_t rsp;

	uint64_t r8;
	uint64_t r9;
	uint64_t r10;
	uint64_t r11;
	uint64_t r12;
	uint64_t r13;
	uint64_t r14;
	uint64_t r15;

	uint64_t rip;     // Instruction Pointer
	uint64_t rflags;  // Flags register

	uint64_t cs;      // Code Segment
	uint64_t ss;      // Stack Segment
};
enum ProcState 
{
	READY,
	RUNNING,
	BLOCKED,
	TERMINATED
};

struct Process process_table[MAX_PROCESSES];

int find_free_slot() {
	for (int i = 0; i < MAX_PROCESSES; i++) 
	{
		if (process_table[i].process_id == -1)	// If the slot is free
		{  
			return i;
		}
	}
	return -1;	// If there is no free slot, return a default value, thus the process won't start
}

struct Process* create_process(uint64_t mem_to_allocate, char exec_path[], unsigned char memoryArray[])
{
	struct Process process;
	process.processstate = READY;
//	*memoryArray = malloc(mem_to_allocate);
	process.process_id = find_free_slot();
}
